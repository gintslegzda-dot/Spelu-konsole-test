#include <Bluepad32.h>
#include <U8g2lib.h>
#include <Wire.h>

// ====== DISPLEJS ======
U8G2_ST7920_128X64_F_SW_SPI u8g2(
  U8G2_R0,
  18, 23, 5, 22
);

// ====== GAMEPAD ======
GamepadPtr gp;

// ====== BUZZER ======
#ifndef BUZZER_PIN
#define BUZZER_PIN 4
#endif

// ====== SKAŅAS (MENU + TETRIS) ======
void menuMoveSound()    { tone(BUZZER_PIN, 900, 40); }
void menuSelectSound()  { tone(BUZZER_PIN, 1200, 80); }
void menuBackSound()    { tone(BUZZER_PIN, 400, 80); }

void beep(int freq, int dur) { tone(BUZZER_PIN, freq, dur); }

void soundRotate()     { beep(1200, 30); }
void soundSoftDrop()   { beep(500, 20); }
void soundHardDrop()   { beep(300, 40); }
void soundLineClear()  { beep(800, 80); delay(40); beep(1000, 80); }
void soundLevelUp()    { beep(900, 80); delay(40); beep(1100, 80); delay(40); beep(1400, 150); }
void soundGameOver()   { beep(400, 200); delay(100); beep(250, 300); }

// ====== GAMEBOY TETRIS A-TYPE ======
int melodyA[] = {
  659,493,523,587,523,493,440,440,523,659,587,523,493,523,587,659,
  523,440,440,493,523,587,523,493,440,493,523,587,659,523,440,440
};

int noteDurA[] = {
  150,150,150,300,300,300,300,150,150,150,300,300,300,150,150,300,
  300,300,300,150,150,150,300,300,300,150,150,150,300,300,300,300
};

void playTetrisA() {
  for (int i = 0; i < 32; i++) {
    tone(BUZZER_PIN, melodyA[i], noteDurA[i]);
    delay(noteDurA[i] * 1.3);
  }
}

// ====== MENU ICON SIZE ======
const int ICON_W = 48;
const int ICON_H = 24;

// ====== MENU ITEMS ======
enum GameID {
  GAME_TETRIS,
  GAME_SNAKE,
  GAME_INVADERS,
  GAME_BREAKOUT,
  GAME_2048,
  GAME_COUNT
};

int menuIndex   = 0;
int currentGame = -1;

// ====== ICON POSITIONS ======
struct IconPos {
  int x;
  int y;
};

IconPos menuIcons[GAME_COUNT] = {
  {  5,  5 },   // Tetris
  { 75,  5 },   // Snake
  {  5, 35 },   // Invaders
  { 75, 35 },   // Breakout
  { 40, 55 }    // 2048
};

// ====== PROTOTIPI TETRIM ======
void startTetris();
void tetrisLoop();
void returnToMenu();

// ====== DRAW ONE MENU ICON ======
void drawMenuIcon(const char* label, int x, int y, bool selected) {
  if (selected) {
    u8g2.drawBox(x, y, ICON_W, ICON_H);
    u8g2.setDrawColor(0);
  } else {
    u8g2.drawFrame(x, y, ICON_W, ICON_H);
    u8g2.setDrawColor(1);
  }

  u8g2.setFont(u8g2_font_6x10_tf);
  int tw = u8g2.getStrWidth(label);
  int tx = x + (ICON_W - tw) / 2;
  int ty = y + ICON_H / 2 + 3;
  u8g2.drawStr(tx, ty, label);

  u8g2.setDrawColor(1);
}

// ====== DRAW MENU ======
void drawMenu() {
  u8g2.clearBuffer();

  drawMenuIcon("TETRIS",    menuIcons[0].x, menuIcons[0].y, menuIndex == 0);
  drawMenuIcon("SNAKE",     menuIcons[1].x, menuIcons[1].y, menuIndex == 1);
  drawMenuIcon("INVADERS",  menuIcons[2].x, menuIcons[2].y, menuIndex == 2);
  drawMenuIcon("BREAKOUT",  menuIcons[3].x, menuIcons[3].y, menuIndex == 3);
  drawMenuIcon("2048",      menuIcons[4].x, menuIcons[4].y, menuIndex == 4);

  u8g2.sendBuffer();
}

// ====== GAME START ROUTER ======
void startGame(int id) {
  currentGame = id;
  if (id == GAME_TETRIS) startTetris();
}

// ====== MENU NAVIGATION ======
void updateMenu(GamepadPtr gp) {
  if (!gp) return;

  static uint8_t lastDpad = 0;
  uint8_t d = gp->dpad();

  if (d != lastDpad) {
    if (d & DPAD_LEFT) {
      if (menuIndex == 1) menuIndex = 0;
      else if (menuIndex == 3) menuIndex = 2;
      menuMoveSound();
    }
    if (d & DPAD_RIGHT) {
      if (menuIndex == 0) menuIndex = 1;
      else if (menuIndex == 2) menuIndex = 3;
      menuMoveSound();
    }
    if (d & DPAD_UP) {
      if (menuIndex == 2) menuIndex = 0;
      else if (menuIndex == 3) menuIndex = 1;
      else if (menuIndex == 4) menuIndex = 2;
      menuMoveSound();
    }
    if (d & DPAD_DOWN) {
      if (menuIndex == 0) menuIndex = 2;
      else if (menuIndex == 1) menuIndex = 3;
      else if (menuIndex == 2 || menuIndex == 3) menuIndex = 4;
      menuMoveSound();
    }
  }

  lastDpad = d;

  static bool lastX = false;
  bool x = gp->x();

  if (x && !lastX) {
    menuSelectSound();
    startGame(menuIndex);
  }

  lastX = x;
}

// ====== RETURN TO MENU ======
void returnToMenu() {
  menuBackSound();
  currentGame = -1;
}

// ====== EMPTY GAME PLACEHOLDERS ======
void startSnake() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(10, 30, "SNAKE nav vel uztaisits");
  u8g2.drawStr(10, 50, "Nospied X lai atgrieztos");
  u8g2.sendBuffer();

  if (gp && gp->x()) returnToMenu();
}

void startInvaders() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(10, 30, "INVADERS nav vel uztaisits");
  u8g2.drawStr(10, 50, "Nospied X lai atgrieztos");
  u8g2.sendBuffer();

  if (gp && gp->x()) returnToMenu();
}

void startBreakout() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(10, 30, "BREAKOUT nav vel uztaisits");
  u8g2.drawStr(10, 50, "Nospied X lai atgrieztos");
  u8g2.sendBuffer();

  if (gp && gp->x()) returnToMenu();
}

void start2048() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(10, 30, "2048 nav vel uztaisits");
  u8g2.drawStr(10, 50, "Nospied X lai atgrieztos");
  u8g2.sendBuffer();

  if (gp && gp->x()) returnToMenu();
}

// ====== GAMEPAD CALLBACKS ======
void onConnectedGamepad(GamepadPtr g) { gp = g; }
void onDisconnectedGamepad(GamepadPtr g) { gp = nullptr; }

// ====== SETUP ======
void setup() {
  Serial.begin(115200);
  BP32.setup(&onConnectedGamepad, &onDisconnectedGamepad);
  BP32.forgetBluetoothKeys();
  u8g2.begin();
  pinMode(BUZZER_PIN, OUTPUT);
  randomSeed(micros());
}

// ====== MAIN LOOP ======
void loop() {
  BP32.update();

  if (currentGame == -1) {
    updateMenu(gp);
    drawMenu();
    return;
  }

  if (currentGame == GAME_TETRIS)   { tetrisLoop();   return; }
  if (currentGame == GAME_SNAKE)    { startSnake();   return; }
  if (currentGame == GAME_INVADERS) { startInvaders();return; }
  if (currentGame == GAME_BREAKOUT) { startBreakout();return; }
  if (currentGame == GAME_2048)     { start2048();    return; }
}
#include <Bluepad32.h>
#include <U8g2lib.h>

// ====== NO MAIN ======
extern GamepadPtr gp;
extern U8G2_ST7920_128X64_F_SW_SPI u8g2;
void returnToMenu();
void soundRotate();
void soundSoftDrop();
void soundHardDrop();
void soundLineClear();
void soundLevelUp();
void soundGameOver();
void playTetrisA();

// ====== TETRIS STATUSI ======
bool tetrisRunning = false;
bool inIntro = true;
bool paused = false;
bool gameOver = false;

int level = 0;
int linesCleared = 0;
int score = 0;

unsigned long lastDrop = 0;
unsigned long dropInterval = 600;

// ====== TETRIS REŽĢIS ======
const int GRID_W = 8;
const int GRID_H = 16;
const int CELL   = 8;

int grid[GRID_H][GRID_W] = {0};

// ====== KOORDINĀTES DISPLEJAM ======
int mapX(int x, int y) {
  return y * CELL + (128 - GRID_H * CELL) / 2;
}

int mapY(int x, int y) {
  return (GRID_W - 1 - x) * CELL + (64 - GRID_W * CELL) / 2;
}

// ====== BLOKS ======
struct Block {
  int x, y;
  int shape;
  int rotation;
};

Block current;

// ====== TETROMINO FORMAS ======
const uint8_t baseShapes[7][4][4] = {
  {{0,0,0,0},{1,1,1,1},{0,0,0,0},{0,0,0,0}}, // I
  {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}}, // O
  {{0,0,0,0},{1,1,1,0},{0,1,0,0},{0,0,0,0}}, // T
  {{0,0,0,0},{1,1,1,0},{1,0,0,0},{0,0,0,0}}, // L
  {{0,0,0,0},{1,1,1,0},{0,0,1,0},{0,0,0,0}}, // J
  {{0,0,0,0},{0,1,1,0},{1,1,0,0},{0,0,0,0}}, // S
  {{0,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,0,0}}  // Z
};

// ====== ROTĀCIJA ======
uint8_t getCell(int shape, int rot, int i, int j) {
  switch (rot & 3) {
    case 0: return baseShapes[shape][i][j];
    case 1: return baseShapes[shape][3-j][i];
    case 2: return baseShapes[shape][3-i][3-j];
    case 3: return baseShapes[shape][j][3-i];
  }
  return 0;
}

// ====== BLOKA PALAIŠANA ======
void spawnBlock() {
  current.x = GRID_W / 2 - 2;
  current.y = 0;
  current.shape = random(0, 7);
  current.rotation = 0;
}

// ====== KOLĪZIJA ======
bool checkCollision(int nx, int ny, int nRot) {
  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      if (!getCell(current.shape, nRot, i, j)) continue;
      int gx = nx + j;
      int gy = ny + i;
      if (gx < 0 || gx >= GRID_W || gy >= GRID_H) return true;
      if (gy >= 0 && grid[gy][gx]) return true;
    }
  }
  return false;
}

// ====== BLOKA NOLIKŠANA ======
void lockBlock() {
  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      if (getCell(current.shape, current.rotation, i, j)) {
        int gx = current.x + j;
        int gy = current.y + i;
        if (gx >= 0 && gx < GRID_W && gy >= 0 && gy < GRID_H) {
          grid[gy][gx] = 1;
        }
      }
    }
  }
}

// ====== LĪNIJU DZĒŠANA ======
void clearLines() {
  for (int y = GRID_H - 1; y >= 0; y--) {
    bool full = true;
    for (int x = 0; x < GRID_W; x++) {
      if (!grid[y][x]) full = false;
    }
    if (full) {
      linesCleared++;
      score += 100;

      soundLineClear();

      int oldLevel = level;
      level = linesCleared / 10;
      if (level > oldLevel) soundLevelUp();

      dropInterval = 600 - level * 50;
      if (dropInterval < 150) dropInterval = 150;

      for (int yy = y; yy > 0; yy--)
        for (int x = 0; x < GRID_W; x++)
          grid[yy][x] = grid[yy - 1][x];

      for (int x = 0; x < GRID_W; x++) grid[0][x] = 0;

      y++;
    }
  }
}

// ====== STOP TETRIS ======
void stopTetris() {
  tetrisRunning = false;
  returnToMenu();
}

// ====== TETRIS GAMEPAD ======
void readTetrisGamepad() {
  if (!gp || !gp->isConnected()) return;

  static bool lastX = false;
  bool x = gp->x();

  // X = atpakaļ uz izvēlni (ja neesam intro)
  if (x && !lastX && !inIntro) {
    stopTetris();
    return;
  }
  lastX = x;

  // X intro ekrānā = sākt spēli + melodija
  if (x && inIntro) {
    playTetrisA();
    inIntro = false;
    paused = false;
    gameOver = false;
    score = 0;
    linesCleared = 0;
    level = 0;
    dropInterval = 600;
    memset(grid, 0, sizeof(grid));
    spawnBlock();
    return;
  }

  if (paused || gameOver || inIntro) return;

  static bool lastA = false;
  bool a = gp->a();
  if (a && !lastA) {
    soundRotate();
    int nr = (current.rotation + 1) % 4;
    if (!checkCollision(current.x, current.y, nr))
      current.rotation = nr;
    else if (!checkCollision(current.x - 1, current.y, nr)) {
      current.x--;
      current.rotation = nr;
    } else if (!checkCollision(current.x + 1, current.y, nr)) {
      current.x++;
      current.rotation = nr;
    }
  }
  lastA = a;

  uint8_t d = gp->dpad();
  if ((d & DPAD_LEFT)  && !checkCollision(current.x - 1, current.y, current.rotation)) current.x--;
  if ((d & DPAD_RIGHT) && !checkCollision(current.x + 1, current.y, current.rotation)) current.x++;
  if ((d & DPAD_DOWN)  && !checkCollision(current.x, current.y + 1, current.rotation)) {
    current.y++;
    soundSoftDrop();
  }

  static bool lastB = false;
  bool b = gp->b();
  if (b && !lastB) {
    while (!checkCollision(current.x, current.y + 1, current.rotation)) {
      current.y++;
    }
    soundHardDrop();
  }
  lastB = b;
}

// ====== ZĪMĒŠANA ======
void drawTetrisScore() {
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.setFontDirection(3);
  u8g2.drawStr(8, 61, ("Score: " + String(score)).c_str());
  u8g2.drawStr(17,61, ("Lvl: " + String(level)).c_str());
  u8g2.setFontDirection(0);
}

void drawTetrisIntro() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_logisoso28_tr);
  u8g2.drawStr(5, 40, "TETRIS");
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(10, 60, "Nospied X lai sāktu");
  u8g2.sendBuffer();
}

void drawTetrisPause() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(40, 30, "PAUZE");
  u8g2.sendBuffer();
}

void drawTetrisGameOver() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.drawStr(30, 25, "GAME OVER");
  u8g2.drawStr(30, 40, ("Score: " + String(score)).c_str());
  u8g2.drawStr(10, 55, "Nospied X lai sāktu");
  u8g2.sendBuffer();
}

void drawTetrisGame() {
  u8g2.clearBuffer();

  for (int y = 0; y < GRID_H; y++)
    for (int x = 0; x < GRID_W; x++)
      if (grid[y][x])
        u8g2.drawBox(mapX(x, y), mapY(x, y), CELL, CELL);

  for (int i = 0; i < 4; i++)
    for (int j = 0; j < 4; j++)
      if (getCell(current.shape, current.rotation, i, j)) {
        int gx = current.x + j;
        int gy = current.y + i;
        if (gy >= 0)
          u8g2.drawBox(mapX(gx, gy), mapY(gx, gy), CELL, CELL);
      }

  drawTetrisScore();
  u8g2.sendBuffer();
}

// ====== START TETRIS ======
void startTetris() {
  tetrisRunning = true;
  inIntro = true;
  paused = false;
  gameOver = false;
  score = 0;
  linesCleared = 0;
  level = 0;
  dropInterval = 600;
  memset(grid, 0, sizeof(grid));
  spawnBlock();
}

// ====== TETRIS LOOP ======
void tetrisLoop() {
  readTetrisGamepad();

  if (inIntro)   { drawTetrisIntro();    return; }
  if (gameOver)  { drawTetrisGameOver(); return; }
  if (paused)    { drawTetrisPause();    return; }

  if (millis() - lastDrop > dropInterval) {
    lastDrop = millis();
    if (!checkCollision(current.x, current.y + 1, current.rotation))
      current.y++;
    else {
      lockBlock();
      clearLines();
      spawnBlock();
      if (checkCollision(current.x, current.y, current.rotation)) {
        gameOver = true;
        soundGameOver();
      }
    }
  }

  drawTetrisGame();
}
